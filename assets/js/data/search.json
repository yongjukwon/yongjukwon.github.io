[ { "title": "Java's Concurrency - 4 (Liveness)", "url": "/posts/java-concurrency-4-liveness/", "categories": "Programming, Java", "tags": "Java, Thread", "date": "2022-08-22 21:03:00 -0700", "snippet": "이번 포스팅에서는 저번에 글이 길어져 포함하지 않은 Liveness에 대해서 알아볼 것이다.⒈ Liveness?동시에 실행되는 어플리케이션을 시간적으로 적절하게 실행시키는 것을 Liveness라고 한다. 한국말로 해석한 것을 찾아보니 활동성이라고 한다. 아래에서 가장 흔한 liveness 문제인 deadlock에 대해 알아보고 다른 두 가지 문제인 starvation과 livelock도 간단히 알아보도록 하자.⒉ DeadlockDeadlock은 두 개 혹은 그 이상의 쓰레드가 서로를 기다리며 영원히 blocked 된 상태다. 예를 들어, 친구인 A와 B가 있고 이 둘 사이에는 꼭 따라야만 하는 한 가지 규칙이 있다고 가정해보자. 이 규칙은 한 사람이 다른 사람에게 고개를 숙여 인사하면 인사를 받은 사람이 인사할 때까지 처음 인사를 한 사람은 계속 고개를 숙이고 있어야 한다. 이 규칙의 맹점은 무엇일까?바로 두 사람이 동시에 인사를 하는 경우를 생각하지 않았다. 그렇다면 두 사람이 동시에 인사를 하면 어떻게 될까? 아래 코드를 통해 알아보자.public class Deadlock { static class Friend { private final String name; public Friend(String name) { this.name = name; } public String getName() { return this.name; } public synchronized void bow(Friend bower) { System.out.printf(\"%s: %s has bowed to me!\\n\", this.name, bower.getName()); bower.bowBack(this); } public synchronized void bowBack(Friend bower) { System.out.printf(\"%s: %s has bowed back to me!\\n\", this.name, bower.getName()); } } public static void main(String[] args) { final Friend a = new Friend(\"A\"); final Friend b = new Friend(\"B\"); // b가 a에게 인사한다, 인사 후 a는 b에게 다시 인사 해야 한다. 하지만 밑 쓰레드가 시작되면서 b의 lock을 own한 후 release하지 않으면 b.bowBack(a)가 실행될 수 없다. new Thread(() -&gt; a.bow(b)).start(); // a가 b에게 인사한다, 인사 후 b는 a에게 다시 인사 해야 한다. 하지만 위 쓰레드가 끝나지 않았기 때문에(a의 lock을 release하지 않았기 떄문에) a.bowBack(b)가 실행될 수 없다. new Thread(() -&gt; b.bow(a)).start(); }}IntelliJ의 debugger를 통해 이 두 쓰레드의 상태를 보면 아래와 같다. Thread-0@780은 Thread-1@783이 lock을 release하기를 기다리고 있고, 똑같이 반대로 Thread-1@783은 Thread-0@780이 lock을 release하기를 기다리고 있다.이 상태를 우리는 deadlock이라고 부른다.Deadlock⒊ Starvation and LivelockStarvation과 livelock은 deadlock보다는 덜 흔한 문제이지만 여전히 개발자라면 마주칠 수 있는 문제들이다.⑴ Starvation Starvation은 쓰레드가 다른 쓰레드들과 공유하는 자원들에 접근할 수 없어서 더 이상 진행할 수 없는 상태이다. 보통 ‘greedy’ threads에 의해 일어나는 상황이다.하나의 예로, 어떤 오브젝트가 synchronized method를 제공하는데 내부의 코드가 시간이 오래 걸리는 작업이라고 가정해보자. 그런데 어떤 한 쓰레드가 이 메소드를 자주 불러서 다른 쓰레드들이 접근할 때마다 접근이 불가능할 수 있는데 이 상황을 starvation이라고 부른다.⑵ Livelock Livelock은 두 쓰레드가 서로에게 의존할 떄 생기는 문제인데, deadlock과는 달리 쓰레드들이 blocked 상태가 되지는 않는다. 아래 코드 예시를 통해서 알아보자.경찰과 범인 그리고 납치 된 사람이 있다. 범인은 경찰이 돈을 주면 납치된 사람을 풀어주기로 했고, 경찰은 돈을 주려고 한다. 아래 코드를 실행시키면 어떤 상황이 벌어질까?/** * @author www.codejava.net (All code below) */public class Criminal { // 납치범 private boolean hostageReleased = false; public void releaseHostage(Police police) { while (!police.isMoneySent()) { System.out.println(\"Criminal: waiting police to give ransom\"); try { Thread.sleep(1000); // 경찰로부터 돈을 기다리는중 } catch (InterruptedException ex) { ex.printStackTrace(); } } System.out.println(\"Criminal: released hostage\"); this.hostageReleased = true; } public boolean isHostageReleased() { return this.hostageReleased; }}public class Police { private boolean moneySent = false; public void giveRansom(Criminal criminal) { while (!criminal.isHostageReleased()) { System.out.println(\"Police: waiting criminal to release hostage\"); try { Thread.sleep(1000); } catch (InterruptedException ex) { ex.printStackTrace(); } } System.out.println(\"Police: sent money\"); this.moneySent = true; } public boolean isMoneySent() { return this.moneySent; }}public class HostageRescueLivelock { static final Police police = new Police(); static final Criminal criminal = new Criminal(); public static void main(String[] args) { Thread t1 = new Thread(() -&gt;police.giveRansom(criminal)).start(); Thread t2 = new Thread(() -&gt; criminal.releaseHostage(police)).start(); }}서로의 상태를 hold하고 있고 업데이트를 하지 못 하기 때문에 결국에는 아래와 같이 두 쓰레드 모두 계속 같은 statement만 프린트 할 것이다. 실생활의 예로 들어보자면 좁은 복도에서 서로 다 방향에서 오고 있던 두 사람이 길을 비켜주기 위해 방향을 바꾸는데 서로 계속 같이 바꾸는 바람에 둘 다 지나갈 수 없게 되는 상태에 비유할 수 있다.Livelock⒋ RetrospectiveOracle의 공식 documentation을 읽으면서 Concurrency에 대해서 정리해봐야지 하면서 시작한 시리즈 였는데 4개까지 쓸 줄은 몰랐다. 이 뒤로도 같은 카테고리의 내용이 있는데 지금까지의 내용보다 High-level의 Concurrency를 다루는 내용이다. 내용이 많지는 않아서 두 번 정도 포스팅을 더 하면 마무리할 수 있을 것 같다. 블로그 스터디는 마지막 주 이지만 계속 써 나가서 더 깊이 알고 있는 자바 개발자가 되야지.!⒌ ReferenceOracle Java DocumentationUnderstanding Deadlock, Livelock and Starvation with Code Examples in Java" }, { "title": "Java's Concurrency - 3 (Synchronization)", "url": "/posts/java-concurrency-3-synchronization/", "categories": "Programming, Java", "tags": "Java, Thread", "date": "2022-08-05 23:07:00 -0700", "snippet": "⒈ What is Synchronization?여러 쓰레드들은 오브젝트나 필드같은 resource들을 서로 공유한다. 이는 두 가지 문제를 일으킬 수 있는데, ¹ 쓰레드들끼리의 충돌과 ² 메모리의 inconsistency이다. Synchronization은 이 문제들을 해결할 수 있는 방법이다. Synchronization은 thread contention 을 제공함으로써 이루어지는데 이는 두 개 이상의 쓰레드가 같은 resource에 동시에 접근하려고 시도할 때 하나 혹은 그 이상의 쓰레드를 상대적으로 느리게 실행시키거나 혹은 실행을 늦추는 방법이다.이 포스트에서는 두 가지 문제점이 어떻게 일어날 수 있는지 먼저 알아보고, 해결 방법까지 알아보도록 하자.⒉ Thead interference아래와 같이 간단한 Counter 클래스가 있다. Variable c의 값을 변경하는 두 메소드(increment, decrement)와 accessor(value)가 존재한다. increment가 불려지면 c에 1이 더해지고, decrement가 불려지면 c에서 1이 빼진다. 하지만 여러 쓰레드가 동시에 이 Counter 오브젝트를 reference 한다면 이런 당연한 계산들이 원하는대로 실행되지 않을 수 있다.class Counter { private int c = 0; public void increment() { c++; } public void decrement() { c--; } public int value() { return c; }}Thread interference는 두 operation이 같은 data를 가지고 각각 다른 쓰레드에서 실행될 때 일어난다. 아래 예에서 c++; 혹은 c–;가 간단한 하나의 expression으로 보일 수 있지만 JVM에서는 이 간단한 expression도 여러 과정으로 translate 될 수 있다. c++를 예로 들면 다음과 같은 과정으로 나뉘어질 수 있다. 현재 c 의 값을 가져온다 불러온 값에 1을 더한다 더해진 값을 c에 다시 저장한다.c–도 두번째 과정에서 값을 더하는 것 대신 빼는 과정을 넣는다면 똑같이 표현할 수 있다. 자, 이제 thread interference가 일어나는 과정을 한 번 적어보자. Thread A는 increment를 부르고, Thread B는 decrement를 부른다고 가정하자. Thread A: 현재 c 의 값을 가져온다 Thread B: 현재 c 의 값을 가져온다 Thread A: 불러온 c의 값에 1을 더한다; c = 1 Thread B: 불러온 c의 값에서 1을 뺀다; c = -1 Thread A: 더해진 값을 c에 저장한다; c = 1 Thread B: 뺀 값을 c에 저장한다; c = -1Thread A의 값은 B에 의해 overwrite 된다. 이 시나리오는 여러 가지 일어날 수 있는 시나리오들 중 하나일 뿐이다. 상황에 따라서 B의 값이 A의 값으로 overwrite 될 수도 있고, 혹은 아무 에러가 없이 실행 될 수도 있다. 이처럼 결과를 예상할 수 없기 때문에 thread interference에 의해 일어나는 버그는 찾기도 힘들고 고치기도 힘들다.⒊ Memory consistency errorsMemory consistency errors는 한 쓰레드에서 실행된 코드가 다른 모든 쓰레드들에게 보여지지 않을 때 일어나는 에러이다. 예를 들면, 아래 코드와 같이 counter variable을 thread A가 와 thread B가 ++ operator로 값을 1씩 증가시켰을 때 결과값이 00, 01, 10, 혹은 11이 나올 수 있다는 뜻이다. (예시일뿐!) int counter = 0; // thread A counter++; // thread B counter++; // thread A System.out.print(counter); // thread B System.out.print(counter); // Result could be 00, 01, 10, or 11Memory consistency error는 엄밀히 말하면 Java가 아니고 CPU에 의해 일어나는 에러이다. 여기서 자세히 설명하는 것은 무리가 있고, 간단하게 설명하고 넘어가도록 하겠다.CPU가 어떤 값을 쓰는(write) 작업을 할 때에는 다른 작업들은 실행될 수 없다. 그래서 어떤 값이 쓰여질 때에는 다른 쓰레드들이 그 값을 가져올 수 없기 떄문에 쓰레드들은 수시로 그 값을 가져갈 수 있는지 확인을 해야 한다. 값을 가져갈 수 있는 상황이 되면 값을 읽게 되는데 이 순서가 값이 쓰여진대로(write) 혹은 프로그래머가 실행한 순서대로 가져오는 게 아니기 때문에 이 경우에 memory consistency error가 일어날 수 있다.개발자에게 중요한 것은 memory consistency error를 어떻게 방지할 수 있는가이다. Java documentation 에서는 happens-before relationship을 만들라고 하는데, 말 그대로 어떤 작업 전에 모든 과정이 일어나게끔해서 그 결과가 다른 쓰레드들에게 visible 하게끔 코드를 작성하라는 것이다. 마치 수학시간에 배운 필요조건, 충분조건처럼 어떤 메소드나 클래스를 happens-before relationship을 가지게끔 만들면 memory consistency error를 방지 할 수 있다는 말이다.우리가 지난 두 포스팅 중에 이미 이 관계를 의도하지 않고 이 관계를 만들어 사용했는데, Thread.start 와 Thread.join이 그것들이다. 간단하게 설명할텐데 그 전에 왜 이것들이 그런 관계를 만들 수 있는지 한 번 생각해보고 읽도록 하자. 어떤 쓰레드에서 Thread.start를 사용해 쓰레드를 실행했다면 그 전에 있는 코드는 실행된 쓰레드에게 모두 visible하다 성공적으로 Thread.join을 실행되었다면 join된 쓰레드 안에서 실행된 모든 코드는 Thread.join을 실행한 쓰레드에서 모두 visible하다이 외에도 더 여러가지 happens-before relationship 을 만들어 주는 여러 시나리오가 있는데, 궁금하다면 Memory Consistency Properties 혹은 17.4.5. Happens-before Order 를 참고해보자.⒋ Synchronized methods자바는 두 가지 기본 synchronization 방법을 제공하는데, ¹synchronized methods 와 ²synchronized statements이다. 이번 섹션에서는 synchronized methods에 대해 알아보고 다음 섹션(5.Implicit Locks and Synchronization)에서 synchronized statements에 대해 알아볼 것이다.메소드를 synchronized 로 만들기 위해서는 synchronized라는 키워드를 access modifier 뒤에 붙여주면 된다.e.g)public class SynchronizedCounter { private int c = 0; public synchronized void increment() { c++; } public synchronized void decrement() { c--; } public synchronized int value() { return c; }}메소드를 synchronized로 만들어 주면 그렇지 않을 때와 비교해 두 가지가 달라진다. 다른 쓰레드들이 메소드를 동시에 부를 수 없게 된다. 한 쓰레드가 synchronized method를 부르면, 같은 메소드를 실행한 다른 쓰레드들은 실행되고 있는 쓰레드가 끝나기 전까지 실행이 미뤄진다. Synchronized method가 존재한다면 자동적으로 happens-before relationship 이 형성된다. 결론적으로 variable c에 대한 memory consistency error를 방지할 수 있다.결과적으로 Synchronized methods는 앞서 살펴 본 두 가지 문제점 모두 해결할 수 있지만, Liveness와 관련된 문제점을 야기할 수 있는데, 다음 포스팅에서 다룰 예정이다.⒌ Intrinsic Locks and Synchronization1) Intrinsic LocksSynchronization은 intrinsic lock 혹은 monitor lock이라고 불리는 entity에 의해 이루어진다. 즉, 이 lock이 오브젝트의 상태한 access를 매니징하고 happens-before relationship을 만드는 데에 사용된다.모든 오브젝트는 intrinsic lock을 가지고 있다. 어떤 오브젝트의 필드에 대한 권한(access)을 얻기 위해, 쓰레드는 그 오브젝트의 intrinsic lock을 먼저 얻어야 한다. 그리고 모든 작업이 끝나면 그 lock을 release한다. 그래서 우리는 쓰레드가 intrinsic lock을 얻은 시점부터 release할 때까지 그 lock을 소유한다(own)라고 표현한다. 한 쓰레드가 intrinsic lock을 소유하고 있는 한 다른 쓰레드들은 같은 lock을 얻을 수 없다. 즉, 다른 쓰레드들이 그 lock을 얻으려고 하면 모두 block된다.그렇다면 static synchronized method가 실행되면 어떨까? Static method는 object가 아닌 class와 associated 되어 있기 때문에, class의 lock을 이용하게 된다. 즉, static synchronized method가 실행되고 있다면 해당 class에는 다른 쓰레드가 접근할 수 없다.2) Synchronized StatementsSynchronized 코드를 만드는 다른 방법은 Synchronized statements를 사용하는 것이다. Synchronized methods와의 가장 큰 차이점은 Synchronized statements은 오브젝트를 반드시 명시해줘야 하는데 이것이 lock의 scope이다.아래의 예를 보자. MsLunch 클래스는 c1과 c2라는 long variables를 가지고 있고 이 두 variable은 함께 사용 되지 않는다고 가정해보자. 모든 필드는 synchronized 되어야 하지만 c1을 update할 때 c2의 값이 변경되는 것을 막을 필요는 전혀 없다. 만약 우리가 synchronized method를 사용한다면 쓰레드들은 한 번에 하나(c1 혹은 c2)의 값만 업데이트 할 수 있지만 아래처럼 각각 다른 object를 제공함으로써 scope를 줄여 서로의 업데이트가 방해되지 않도록 만들 수 있다.public class MsLunch { private long c1 = 0; private long c2 = 0; private Object lock1 = new Object(); private Object lock2 = new Object(); public void inc1() { synchronized(lock1) { c1++; } } public void inc2() { synchronized(lock2) { c2++; } }}3) Reentrant SynchronizationReentrant Synchronization은 어떤 한 lock을 얻은 쓰레드는 반복해서 그 lock과 associated된 오브젝트나 메소드에 접근할 수 있는 것을 말한다. 예를 들어, recursive 메소드가 synchronized 되었다고 가정했을 때, 해당 lock을 얻은 쓰레드는 recursive 메소드가 끝이날 때까지 lock을 소유하게 된다.⒍ What’s next?다음 포스팅에서는 volatile keyword와 Liveness, 멀티쓰레딩이 실행되는 어플리케이션이 순서대로 실행시킬수 있는 방법,에 대해 알아볼 것이다.⒎ ReferencesSynchronization - OracleJava Synchronized Blocks - Jenkov.comSynchronized Block in Java - Javatpoint.com" }, { "title": "Java's Concurrency - 2 (Thread management)", "url": "/posts/java-concurrency-2-thread-management/", "categories": "Programming, Java", "tags": "Java, Thread", "date": "2022-07-22 22:27:00 -0700", "snippet": "⒈ Background오늘은 지난 글에 이어 현재 동작하고 있는 thread를 control 할 수 있는 세 가지 방법에 대해서 알아보려고 한다. Sleep Interrupts Joins하나씩 알아본 후에 세 가지 방법이 모두 포함된 example을 통해 어떻게 사용할 수 있는지 알아보자.⒉ SleepThread.sleep은 일정 시간동안 현재 실행 되고 있는 작업을 미루는 역할을 한다. 멈춘 작업이 실행되고 있던 프로세서를 다른 쓰레드나 어플리케이션이 이용하게 할 수 있다는 점에서 유용하다.sleep 메소드는 두 가지가 존재 하는데 ¹ millisecond만 넣거나, ² millisecond와 nanosecond를 함께 넣을 수 있다. 후자의 경우 제공된 millisecond + nanosecond로 쓰레드를 멈출 시간을 지정할 수 있다.sleep 메소드를 사용할 때 가장 조심해야 할 점은 우리가 지정한 시간만큼 정확히 쓰레드를 멈춘다는 보장을 하지 못 한다는 점이다. 그 이유는 우리가 지정한 시간이 OS의 timer와 scheduler에 의존하기 때문이다. 간단하게 말하면, 현재 시스템이 바쁜 상태라면 쓰레드는 waiting 상태(아래 Thread life cycle 참고)에서 우리가 지정한 시간보다 더 오래 있을 수 있고, 반대의 경우에는 우리가 지정한 시간만큼 보다 정확하게 있을 것이다. 결론적으로, sleep 메소드는 언제든 우리가 지정한 시간만큼 100% 정확하게 동작하지 않는다는 걸 기억해두자.Thread life cycle (https://commons.wikimedia.org/)또한, sleep period 는 아래에서 알아 볼 interrupts에 의해 종료될 수 있다. 쓰레드가 sleep에 의해 waiting 상태일 때 다른 쓰레드에 의해 방해(interrupt) 받으면 InterruptedException을 던진다.⒊ InterruptsInterrupt는 쓰레드에게 멈추고, 다른 일을 해야한다는 일종의 신호이다. Interrupt에 어떻게 response 할 것 인지는 코드를 작성하는 개발자의 마음이다. 해당 쓰레드를 종료하는 것이 보통이고, 위에서 알아본 Thread.sleep이나 Thread.join() 등 여러가지 메소드들은 InterruptedException을 던진다.각 쓰레드는 각자의 interrupt status를 알려주는 flag를 가지고 있고, 이 flag는 true 혹은 false로 설정될 수 있다. 기본값은 false이고 해당 쓰레드가 interrupted 되면 true로 설정된다.Interrupted 될 쓰레드가 있다면 interruption을 핸들링 할 코드를 반드시 작성해야 한다.Interrupt flag 를 확인할 수 있는 두 가지 메소드가 있는데, ¹interrupted 과 ²isInterrupted 이다. 두 메소드에는 두 가지 큰 차이점이 있는데,⑴ interrupted는 Thread 오브젝트의 static method이고 isInterrupted는 instance method이다. ⑵ interrupted는 실행된 후 interrupt status flag를 clear 하지만 isInterrupted는 flag를 변경하지 않는다.   Interrupted isInterrupted Scope Static method Instance method Clear flag True False isInterrupted는 보통 logging이나 debugging 할 때 쓰이고, 대개는 interrupted를 사용하는 것이 권장된다. 이유는 isInterrupted는 당시의 flag snapshot을 주는 것이기 때문에 다시 실행했을 때 이미 outdated된 status를 줄 수 있기 때문이다. 또한 interrupted를 통해 interrupt status flag가 clear 됐다는 것은 개발자가 그에 대응하는 액션을 취했다는 의미이기 때문이다.⒋ Joinsjoin 메소드는 현재 쓰레드에서 join 메소드가 불려진 쓰레드가 현재 하는 일을 완료할 때까지 기다려줄 수 있도록 한다. join은 sleep과 비슷한 점이 많다. 기다려줄 시간을 지정할 수도 있고 혹은 아무 argument 없이 쓰레드가 완료될 때까지 기다릴 수도 있다. 역시 우리가 지정한 시간을 100% 정확하게 보장 받을 수 없다는 것을 유의하자. 또한 interrupt에 InterruptedException으로 대응하는 점도 같다.⒌ Examplesleep, interrupt과 join을 모두 이용한 example을 통해서 정리해보도록 하자. Comment를 따라서 차근차근 코드를 읽어보고 코드 블럭 밑 정리된 글을 읽어보자.public class SimpleThreads { static void threadMessage(String message) { // 쓰레드 정보와 메세지를 표현해 줄 helper method String threadName = Thread.currentThread().getName(); System.out.format(\"%s: %s%n\", threadName, message); } private static class MessageLoop implements Runnable { // 실제 실행될 thread public void run() { String importantInfo[] = { \"Mares eat oats\", \"Does eat oats\", \"Little lambs eat ivy\", \"A kid will eat ivy too\"}; try { // 4초 텀을 두고 String을 프린트 한다 for (int i = 0; i &lt; importantInfo.length; i++) { Thread.sleep(4000); // 4초를 기다린다 threadMessage(importantInfo[i]); // String을 하나씩 출력 한다 } } catch (InterruptedException e) { // 이 쓰레드가 interrupted 되어 sleep 메소드가 InterruptedException을 던지면 threadMessage(\"I wasn't done!\"); // 메세지 출력 } } } public static void main(String args[]) throws InterruptedException { long patienceInMS = 1000 * 60 * 60; // MessageLoop 쓰레드를 interrupt하기 전 기다릴 시간, 기본값: 1시간 if (args.length &gt; 0) { // 커맨드 라인을 통해 시간을 지정해주면, patienceInMS 값을 변경한다 try { patienceInMS = Long.parseLong(args[0]) * 1000; } catch (NumberFormatException e) { System.err.println(\"Argument must be an integer.\"); System.exit(1); } } threadMessage(\"Starting MessageLoop thread\"); long startTime = System.currentTimeInMS(); // 현재 시간 Thread t = new Thread(new MessageLoop()); // 쓰레드 instantiation t.start(); // 쓰레드 실행 threadMessage(\"Waiting for MessageLoop thread to finish\"); while (t.isAlive()) { // MessageLoop 쓰레드가 살아있는 동안 threadMessage(\"Still waiting...\"); t.join(1000); // MessageLoop 쓰레드가 끝나기를 1초간 기다린다 // 만약 patienceInMS 보다 긴 시간동안 실행되었는데도 아직 MessageLoop가 종료되지 않았다면 if (((System.currentTimeInMS() - startTime) &gt; patienceInMS) &amp;&amp; t.isAlive()) { threadMessage(\"Tired of waiting!\"); t.interrupt(); // MessageLoop를 interrupt 한다 } } threadMessage(\"Finally!\"); }}Comment에 써 놓은 대로 만약 주어진 patienceInMS보다 긴 시간동안 MessageLoop가 실행되고 있다면, interrupt를 통해 MessageLoop가 실행되고 있는 thread가 InterruptedException을 던져서 I wasn't done! 이라는 메세지와 함께 thread를 종료시킨다. thread가 종료되면 t.isAlive()가 false가 되고 Finally! 가 출력되며 프로그램이 종료된다.⒍ ReferenceOracle: ConcurrencyJava: Difference in usage between Thread.interrupted() and Thread.isInterrupted()?" }, { "title": "Java's Concurrency - 1 (Basic)", "url": "/posts/java-concurrency-1-basic/", "categories": "Programming, Java", "tags": "Java, Thread", "date": "2022-07-08 19:51:00 -0700", "snippet": "⒈ Background블로그 스터디원 중 한 분이 Java로 개발할 때 Thread를 따로 만들어주지 않으면 그건 Single-Threaded application인가 라는 질문을 주셔서 간단하게 답해보고, 개발자가 어떻게 Thread를 생성할 수 있는지 간단하게 알아보려고 한다.⒉ Is Java Single-Threaded application without explicitly created threads?JVM이 실행될 때, 보통은 오직 하나의 Non-Daemon Thread(혹은 User Thread)가 존재하게 된다. 우리가 매일 같이 쓰고 있는 main method가 실행되는 main thread이다. Daemon Thread는 JVM에 의해서 background에서 실행되고 garbage collection나 finalizer같은 여러가지 task를 수행한다. 모든 Non-Daemon Thread가 완료되면 프로그램은 끝이 나지만, Daemon Thread의 완료는 프로그램의 종료를 의미 하지 않는다.그렇다면 Java에서 Thread를 explicit하게 만들어주지 않으면 single-threaded application일까?답은 Daemon Thread를 포함해서 답을 하는지에 따라 맞다 일 수도, 아니다 일 수도 있다.예를 들어, 아래 코드처럼 Main method 안에 간단한 코드만 가지고 있을 때(Thread를 따로 생성하지 않았을 때!) 개발자의 입장에서는 single-threaded application이지만 실제로는 Non-Daemon Thread들이 실행 되고 있기 때문이다. public static void main(String[] args) { System.out.println(\"Hello World!\"); }참고로 Daemon Thread는 IDE의 디버거를 통해 쉽게 볼 수 있다.Daemon Threads: Finalizer, Reference Handler, Single Dispatcher가 Daemon Thread에서 실행되고 있다⒊ How to create a thread in JavaJava에서 thread는 Thread 클래스에 의해 생성되는데, 이 클래스를 instantiate하는 두 가지 방법이 있다. Extending Thread class (documentation) Implementing Runnable interface (documentation)둘 중에 어떤 방법을 써야 할까? 실제로는 Runnable interface를 많이 쓰게 된다. Thread class를 extend 하게 되면 다른 클래스를 더 이상 extend 할 수 없기 때문에 Runnable interface를 implement하는 쪽이 조금 더 유연한 프로그램을 만들 수 있기 떄문이다.⒋ Thread classThread class를 이용해 thread를 생성할 때에는 Thread class를 extend한 후 run method안에 실행 될 코드를 작성한다 Parent thread에서 작성한 클래스를 instantiation 후 start method를 이용해 thread를 불러온다 Note: Thread를 실행할 때, run이 아닌 start method를 호출한다. 자세한 내용은 밑(⒍ run() vs start())에서 알아볼 것이다.class PrimeThread extends Thread { // 1. Extend Thread class long minPrime; PrimeThread(long minPrime) { this.minPrime = minPrime; } public void run() { // 2. Write codes to be ran on this thread . . . }}class Main { public static void main(String[] args) { PrimeThread pt = new PrimeThread(143); // 3. Instantiate the class extends Thread pt.start(); // 4. Run the thread }}⒌ Runnable InterfaceRunnable interface를 이용해 thread를 생성할 때에는 Runnable interface를 implement한 후 run method안에 실행 될 코드를 작성한다 Parent thread에서 작성한 클래스를 instantiation 후 Instantiate한 클래스를 새로운 Thread object를 이용해 implement 해준다 새로 만들어진 Thread object를 start method로 불러준다 Note: Runnable interface는 오직 run method 하나만을 가진 interface이고 Thread object를 통해 만들어질 새로운 thread에서 실행될 코드를 담는 역할만을 한다class PrimeRun implements Runnable { // 1. Runnable interface를 implement한 후 long minPrime; PrimeRun(long minPrime) { this.minPrime = minPrime; } @Override public void run() { // 2. run method안에 실행 될 코드를 작성한다 . . . }}class Main { public static void main(String[] args) { PrimeRun p = new PrimeRun(143); // 3. Parent thread에서 작성한 클래스를 instantiation 후 new Thread(p).start(); // 4. Instantiate한 클래스를 새로운 Thread object를 이용해 implement 해준다 // 5. 새로 만들어진 Thread object를 start method로 불러준다 }}⒍ run() vs start()위 코드들에서 봤듯이 thread를 실행시킬 때, 우리는 run 대신 start method를 이용한다. 그 이유는 간단한데, JVM이 start method가 불려질 때 새로운 thread를 만들기 때문이다. run method는 thread에서 실행될 코드에 불과하다. 실제 코드를 통해 간단하게 증명해 보도록 하자.먼저 Java documentation에 적혀 있는 내용을 한 번 보고 가자. It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution  Throws: IllegalThreadStateException - if the thread was already started.자바의 thread는 한번 실행 되고 나면 다시 실행 될 수 없고 만약 다시 실행을 시도하면 exception을 던진다고 한다.다음 코드에는 Thread class를 extend한 PlaygroundChild class가 있고 그 걸 불러내는 Playground class가 존재한다. 그 안에서 run method와 start method를 두 번씩 실행 시켜 보았다. 만약 run method가 thread를 만든다면 두 번째 불려지는 run method는 IllegalThreadStateException을 던져야 한다.결과는 어떨까?public class PlaygroundChild extends Thread { public void run() { // compute primes larger than minPrime for(int i = 0; i &lt; 3; ++i) System.out.print(i + \" \"); System.out.println(); }}public class Playground { public static void main(String[] args) { PlaygroundChild pc = new PlaygroundChild(); pc.run(); // 0 1 2 pc.run(); // 0 1 2 pc.start(); // 0 1 2 pc.start(); /* Exception in thread \"main\" java.lang.IllegalThreadStateException\t at java.base/java.lang.Thread.start(Thread.java:794)\t at playground.Playground.main(Playground.java:10) */ }}결론적으로, run method를 호출하면 thread가 만들어지지 않고 run method자체가 불려지고, start method를 통해서만 새로운 thread를 만들어낼 수 있다.⒎ RetrospectiveThread를 만들 수 있는 방법에 대해서 다시 review 하고 Daemon Thread에 대해서 알아볼 수 있는 좋은 기회가 되었다. 이 글에 이어서 Java의 Concurrency에 대해서 조금 더 자세하게 공부하고 이어서 글을 써 봐야 겠다. 양이 워낙 방대해서 한 글에 담을 수가 없을 것 같아서 시리즈로 글을 써야 할 것 같다 😁⒏ ReferencesThread - OracleRunnable - Oracle" }, { "title": "How does JVM work", "url": "/posts/how-does-jvm-work/", "categories": "Programming, Java", "tags": "Java, JVM, Architecture", "date": "2022-06-24 23:26:00 -0700", "snippet": "이 글을 먼저 읽고 오는 걸 추천드립니다: JVM, JRE and JDK⒈ What is Java Virtual Machine(JVM)Java Virtual Machine(JVM)의 주된 목적은 Java 컴파일러를 통해 변환된 Byte code(.class 파일)를 Machine code로 변환해주는 것이다. 이 글에서는 JVM의 아키텍쳐를 함께 보면서 어떻게 변환 과정이 이루어지는 지 알아볼 것이다.JVM의 아키텍쳐는 아래 그림과 같고, 세 가지 큰 요소로 이루어져 있다. Class Loader Subsystem Runtime Data Area Execution EngineJVM Architecture simple version(careerbless.com)3가지 요소를 하나씩 자세히 알아보며 어떤 sub components들로 구성이 되어 있고 어떻게 동작하는 지 알아보자.⒉ JVM’s 3 components２-⒈ Class Loader SubsystemClass Loader Subsystem 안에서 세 가지 작업이 프로세싱 되는데, Loading, Linking 그리고 Initialization이다.1) Loading: 작성한 코드 내에 정의된 클래스들이 불려진다2) Linking: Verify, Prepare와 Resolve 라는 sub-processing이 이루어진다 Verify: JVM안의 Byte Code Verifier가 클래스 파일들이 제대로 포맷팅 되어 있는지, 구조적으로 정확한지, Valid한 컴파일러에 의해서 컴파일 되었는지 확인하는 역할을 한다. 만약 invalid 하다고 판단이 되면 java.lang.VerifyError를 던진다 Prepare: static variables을 위한 메모리를 할당하고 타입에 따라 default value로 initialize한다 Resolve: symbolic 메모리 레퍼런스들이 원래의 레퍼런스로 변환된다. 3) Initialization: linking process(Prepare, specifically)에서 initialize된 static variables에 할당된 값을 제공하고, static block들이 실행된다.２-⒉ Runtime Data AreasRuntime Data Areas에는 총 5가지 요소가 존재한다.1) Method Area: Static variables를 포함한 모든 클래스 레벨 데이터가 이 곳에 저장된다. JVM안에 오직 한 Method Area만 존재 하기 때문에 모든 resources는 share된다.2) Heap Area: 모든 Objects, instance variables와 arrays가 이 곳에 저장된다. 역시 JVM안에 오직 한 Heap Area만 존재 하므로 모든 resources는 share된다. Method Area와 Heap Area는 여러 threads들에 의해 share되는 메모리기 때문에 thread-safe하지 않다3) Stack Area: 한 thread 당 하나의 stack area가 만들어진다. 그 thread 안에서 불려지는 method들 하나당 하나의 stack이 쌓여 memory에 쌓이고 우리는 stack frame이라고 부른다. 모든 local variables가 저장 되고, 당연히 share되지 않는 resource이기 때문에 thread-safe하다. Stack frame은 다시 세 가지 작은 요소들로 나누어지는데, Local Variable Array: 말 그대로 local variable을 담는 array이다. Method의 모든 parameter와 local variable들을 담고, array의 한 slot당 4 Bytes가 할당된다. int, float과 reference는 1 slot을 차지하고 Byte, short와 char은 담기기 전에 int type으로 변환되기 떄문에 역시 1 slot을 차지한다. double과 long은 2 slots을 차지하고 Boolean은 JVM마다 다르지만 거의 모든 JVM이 1 slot을 할당한다. (e.g.) 아래 코드 속 parameter들은 그 아래 그림처럼 local variable array에 담기게 된다. class Example { public void bike(int i, long l, float f, double d, Object o, byte b) { } } local_variable_array(geeksforgeeks.org) Operand stack: 하나의 workspace 또는 work area 라고 생각할 수 있고, calculation 중간의 결과들을 저장할 수 있는 장소이다\\ Frame data: Constant Pool, 이전 스택 프레임에 대한 정보, 현재 method가 속한 클래스에 대한 reference 등의 정보를 갖는다4). PC Registers: 하나의 thread 당 하나의 PC register가 생성된다. PC register는 현재 실행되는 instruction의 address를 가지고 있다. 만약 현재 실행되는 method가 native라면 PC register의 값은 undefined이다5) Native Method Stack: Native method의 정보를 저장한다. 하나의 thread 당 하나의 native method stack이 생성된다.２-⒊ Execution Engineexecution engine(geeksforgeeks.org)Execution Engine은 RDA에 변환되어 저장된 byte code를 마치 instruction 단위로 읽어서 마치 CPU처럼 하나씩 실행한다. Byte code command는 1-byte의 Opcode와 Operand로 이루어져 있는데, execution engine은 Opcode를 corresponding operand와 함께 실행시키고 다음 Opcode로 넘어간다. 이 과정은 execution engine의 두 요소에 의해 이루어 진다.1) Interpreter: Interpreter는 byte code instruction을 machine code instruction으로 변환한다.2) Just In Time(JIT) Compiler: JIT Compiler의 목적은 performance 향상이다. JIT Complier안의 Profiler는 어떤 한 method가 계속 반복적으로 불리는지 감지하는 역할을 한다. 반복적으로 불리는 method를 Hotspot 이라고 부르며 Hotspot이 정해진 thread hold value(JVM마다 다름)에 도달하면 JIT Compiler가 그 Hotspot에 해당되는 native code를 생성한다. 그 뒤로는 interpreter가 매 번 native code로 변환하는 프로세스 대신 JIT compiler에 의해 생성된 native code가 사용함으로써 performance 향상을 이룬다.⒊ RetrospectiveJVM architecture에 관련된 동영상도 많이 보고, 글도 많이 읽으면서 공부할 때는 너무 재미있고 사람들에게 알려줄 생각에 들떠 있었다. 글을 적기 시작하니 도대체 어디서부터 어디까지 설명을 해야할 지 감이 안잡혔다😭. 자세히까지는 알 필요가 없지만 CPU architecture, Stack, Heap, references 등에 대한 기본적인 지식을 가진 사람을 독자로 잡고 글을 써 보았다. 그렇지 않으면 끝까지 읽는 사람이 손에 꼽을 정도로 길고 지루한 글이 될 것 같았다(그렇게 자세한 글을 쓸 자신도 없다🫠). 그래도 아직 부족한 글이라 이미지나 예를 많이 넣어서 조금 더 쉽게 이해할 수 있는 글로 완성 시켜야겠다.⒋ ReferencesHow JVM Works - JVM Architecture?waytoeasylearn.comThe JVM Architecture Explained - DzoneJVM Architecture -tutorial, Youtube" }, { "title": "JVM, JRE and JDK", "url": "/posts/jvm-jre-jdk/", "categories": "Programming, Java", "tags": "Java, JVM, JRE, JDK", "date": "2022-06-19 16:23:00 -0700", "snippet": "⒈ Background저번 블로그 포스팅 스터디 중 compiler와 interpreter 이야기가 나왔다. 자바가 어떻게 class 파일로 컴파일이 되는지, 그리고 실행 되는지 이야기 해보다가 예전에 같은 궁금증을 가지고 찾아본 내용을 바탕으로 글을 작성해본다.⒉ What is JVM?Java Virtual Machine(JVM)은 Java byte code를 machine code로 translate하여 실행 될 수 있는 환경을 제공한다. Machine code는 프로세서마다 다르기 때문에, 운영체제마다 혹은 같은 운영체제지만 다른 아키텍쳐에서는 각기 다른 JVM을 설치해줘야 한다.JVM은 자바의 슬로건인 Write once, run anywhere(WORE)의 핵심 요소인데 machine interface를 제공함으로써 자바 어플리케이션을(구체적으로는 .class file) 어떤 환경에서도 실행할 수 있도록 한다. 그러한 이유로 우리는 Java를 platform-independent하다고 한다.tutorial.eyehunts.com결국 우리는 코드를 쓰고 있는 운영체제에서 실행 되는 코드를 쓰고 있는 게 아니라, JVM에서 변환 될 코드를 쓰고 있다고 생각하면 더 직관적으로 이해할 수 있다.JVM만을 따로 설치할 수는 없으며 JRE를 설치하면 함께 설치된다.JVM에 대해 더 자세한 내용을 알고 싶다면👉🏻How does JVM work(In progress)⒊ What is JRE?Java Runtime Environment(JRE)는 JVM을 포함해서 자바 어플리케이션을 실행시키기 위해 필요한 각종 라이브러리나 파일들을 포함하고 있다.개발을 하기 위해서가 아니고 자바 어플리케이션을 실행만 하기 위해서라면 JRE만 설치하면 된다.⒋ What is JDK?Java Development Kit(JDK)는 자바 어플리케이션을 개발하기 위해 필요한 패키지이다. JDK는 JRE와 함께 개발에 필요한 툴(컴파일러, JavaDoc, 디버거 등)을 포함하고 있다.JRE와 JDK에 포함되는 라이브러리나 파일들은 이 그림을 참고하자👉🏻JVM, JRE &amp; JDK (Complex version)⒌ Conclusion따라서 JVM, JRE 그리고 JDK의 관계는 다음과 같다.JVM, JRE &amp; JDK(geeksforgeeks.org)그리고 더욱 깊게 알고 싶은 분들을 위해..🫠JVM, JRE &amp; JDK(oracle.com)⒍ ReferencesOracleDifference between JDK, JRE and JVM" }, { "title": "Lazy Loading", "url": "/posts/lazy-loading/", "categories": "Programming, Java", "tags": "Java, Database, Web Development, REST API, Spring", "date": "2022-06-11 01:28:00 -0700", "snippet": "⒈ Background회사에서 DB에 Blob(Binary Large Object)을 업로드하는 REST API를 만들게 되었다. 현재는 이 오브젝트만 ORM에서 빠져 있는 상태이다. 그 이유는 만약 이 오브젝트가 업로드 될 column을 다른 column들과 같은 방법으로 mapping을 하면 테이블이 읽혀질 때마다 함께 읽혀지기 때문에 Performance가 감소할 수 있기 때문이다. 현재 돌아가는 서비스가 주기적으로 이 오브젝트가 속한 테이블을 읽고 있고, 서비스가 이 오브젝트를 성공적으로 한 번만 읽으면 되기 때문에 Lazy Loading을 possible option으로 생각하고 디자인중이다. 회사에서 사용하게 될 환경은 Java Spring이지만 검색 중 Lazy Loading이 프론트엔드에서도 쓰인다는 걸 알게 됐고 프론트엔드, 백엔드 개발자 모두 이해할 수 있도록 글을 써보려고 한다.⒉ What is Lazy Loading &amp; Eager Loading?Lazy Loading은 다른 말로 Asynchronous Loading이라고도 불리며, 컴퓨터 프로그래밍에서 사용되는 디자인 패턴중의 한가지이다. 주로 웹 서비스 개발 중 오브젝트의 initialization을 필요할 때까지 늦추는 것을 의미한다. 간단한 예로는, 어떤 한 웹 페이지의 밑(스크롤을 내려야만 볼 수 있는 곳)에 존재하는 한 이미지가 우리가 스크롤을 내리기 전까지는 해당 이미지 오브젝트 대신 placeholder가 존재하다가 스크롤을 내렸을 때에서야 그 이미지를 로딩하는 것이 있다.Lazy Loading의 반대로는 Eager Loading이 있다. Eager Loading은 Pre-loading이라고도 불리며 프로그램이 실행되면(코드가 execute되면) 모든 resources를 모두 불러온다. 우리가 이 블로그를 열었을 때 이 블로그 안의 모든 글, 이미지, 동영상 등이 한 번에 불러오는 것을 예로 들 수 있다.⒊ Why do we use Lazy Loading?Lazy Loading을 쓰는 이유로는 단연 performance enhancement가 꼽히겠다. 조금 더 자세히 설명하면, Reduced initial load time/memory 모든 resource가 아닌 일부분만 처음에 불러오기 때문에 load time이 줄어들고 불러오지 않은 resources 덕분에 사용할 메모리도 적어진다 Faster connection to users; better user experience 줄어드는 load time은 유저들에게 더 빠른 contents 제공을 보장한다 Avoiding unnecessary code execution 같은 맥락으로 Lazy loading으로 불려올 resources에 대한 코드들은 불필요한 실행을 피할 수 있다 Cost-effective time/memory 최적화로 불필요한 resources들을 불러오지 않음으로써 운영비용을 아낄 수 있다 단점도 존재하는데, Extra codes Lazy Loading을 위해서 작성해야 하는 코드가 당연히 필요하고, 때로는 생각 외로 복잡해질 수 있다.(편하게 사용할 수 있도록 점점 많은 방법들이 개발되고 있다) Low web rankings Initial load 되지 않는 페이지들이 존재한다면 Search Engine Optimization(SEO) 결과에 영향을 미칠 수 있다. ⒋ Where is Lazy Loading used?이 글을 작성하려고 검색 해 보기 전까지는 프론트엔드에서 Lazy Loading이 사용 된다는 건 생각을 해보지 않았는데 너무나 당연한 사실이었다. 편협한 시야를 언제쯤 넓힐 수 있을까😢프론트엔드와 백엔드 한 가지씩 예를 들어서 Lazy Loading이 어떻게 사용 될 수 있는 지 보려고 한다.Front-endimport React, { Suspense, lazy } from 'react';import { BrowserRouter as Router, Route, Switch } from 'react -router-dom';// lazy-loading syntax in ReactJSconst About = lazy(() =&gt; import('./About'));const App = () =&gt; ( // ... &lt;Route path=\"/\" exact render={() =&gt; ( &lt;div&gt; &lt;h1&gt;This is the main page&lt;/h1&gt; &lt;a href=\"/about\"&gt;Click here&lt;/a&gt; &lt;/div&gt; )} /&gt; // ...);export default App;import React from 'react';const About = () =&gt; { return ( &lt;div&gt; &lt;h1&gt;This is the about section&lt;/h1&gt; &lt;/div&gt; );};export default About; OutputAbout 페이지는 Click here 링크를 클릭해야만 render 된다Back-endpublic class Item { ... @JsonIgnore @OneToMany(cascade = CascadeType.ALL, mappedBy = \"item\") private List&lt;PurchaseItem&gt; purchaseItems = new ArrayList&lt;&gt;(); ...}public class PurchaseItem { ... @JoinColumn(name = \"item_id\") // lazy-loading syntax in Java Spring @ManyToOne(fetch = LAZY, cascade = CascadeType.PERSIST) private Item item; ...}작년에 취업 준비하면서 만들었던 토이 프로젝트에서 마침 lazy loading을 썼던 예가 있어서 가지고 왔다.Inventory Management System을 만들었는데 Item은 많은 PurchaseItem을 List로 가질 수 있고, 이 PurchaseItem들은 영수증에 보여지게 된다. 유저가 구매할 때는 당연히 필요가 없고 구매 후에만 보여지면 되기 때문에 lazy loading을 사용했다. 만약 lazy loading을 하지 않는다면 시스템을 켜는 순간 Item들과 함께 모든 고객들이 구매했던 Item들이 필요 하지도 않은데 모두 load 될 것 이고 당연히 time/memory waste가 발생한다.작은 프로젝트 였지만, 공부를 목적으로 만들었기 때문에 굉장히 큰 시스템이란 가정 하에 performance를 높이기 위해 사용해 보았다.⒌ ConclusionLazy Loading의 단점을 생각해보지는 않았는데, 이번 REST API를 개발 하는 데에 있어서는 큰 걸림돌이 될 것 같지는 않다. 꼭 필요한 코드이기 때문에 첫번째 단점(extra code)은 해당이 안되고, 두번째 단점(SEO results)도 해당이 되지 않는다. 다음주에 앱 디자인 리뷰 미팅이 있는데 이 글을 바탕으로 설명하며 또 다른 pitfalls이 있는지 피드백도 받아보고 새로운 점이 있으면 업데이트 해야지.⒍ ReferencesLazy Loading - WikipediaWhat is Lazy Loading - GeeksforGeeksLazy Loading in ReactJS - TutorialsPointHow to Set Up Lazy Loading for Optimal SEO Results" } ]