<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://yongjukwon.github.io/</id><title>밴쿠버에서 개발하는 펭귄</title><subtitle></subtitle> <updated>2022-08-23T23:03:51-07:00</updated> <author> <name>Yongju Kwon</name> <uri>https://yongjukwon.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://yongjukwon.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://yongjukwon.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Yongju Kwon </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Java's Concurrency - 4 (Liveness)</title><link href="https://yongjukwon.github.io/posts/java-concurrency-4-liveness/" rel="alternate" type="text/html" title="Java's Concurrency - 4 (Liveness)" /><published>2022-08-22T21:03:00-07:00</published> <updated>2022-08-23T22:56:32-07:00</updated> <id>https://yongjukwon.github.io/posts/java-concurrency-4-liveness/</id> <content src="https://yongjukwon.github.io/posts/java-concurrency-4-liveness/" /> <author> <name>Yongju Kwon</name> </author> <category term="Programming" /> <category term="Java" /> <summary> 이번 포스팅에서는 저번에 글이 길어져 포함하지 않은 Liveness에 대해서 알아볼 것이다. ⒈ Liveness? 동시에 실행되는 어플리케이션을 시간적으로 적절하게 실행시키는 것을 Liveness라고 한다. 한국말로 해석한 것을 찾아보니 활동성이라고 한다. 아래에서 가장 흔한 liveness 문제인 deadlock에 대해 알아보고 다른 두 가지 문제인 starvation과 livelock도 간단히 알아보도록 하자. ⒉ Deadlock Deadlock은 두 개 혹은 그 이상의 쓰레드가 서로를 기다리며 영원히 blocked 된 상태다. 예를 들어, 친구인 A와 B가 있고 이 둘 사이에는 꼭 따라야만 하는 한 가지 규칙이 있다고 가정해보자. 이 규칙은 한 사람이 다른 사람에게 고개를 숙여 인사하면 ... </summary> </entry> <entry><title>Java's Concurrency - 3 (Synchronization)</title><link href="https://yongjukwon.github.io/posts/java-concurrency-3-synchronization/" rel="alternate" type="text/html" title="Java's Concurrency - 3 (Synchronization)" /><published>2022-08-05T23:07:00-07:00</published> <updated>2022-08-05T23:07:00-07:00</updated> <id>https://yongjukwon.github.io/posts/java-concurrency-3-synchronization/</id> <content src="https://yongjukwon.github.io/posts/java-concurrency-3-synchronization/" /> <author> <name>Yongju Kwon</name> </author> <category term="Programming" /> <category term="Java" /> <summary> ⒈ What is Synchronization? 여러 쓰레드들은 오브젝트나 필드같은 resource들을 서로 공유한다. 이는 두 가지 문제를 일으킬 수 있는데, ¹ 쓰레드들끼리의 충돌과 ² 메모리의 inconsistency이다. Synchronization은 이 문제들을 해결할 수 있는 방법이다. Synchronization은 thread contention 을 제공함으로써 이루어지는데 이는 두 개 이상의 쓰레드가 같은 resource에 동시에 접근하려고 시도할 때 하나 혹은 그 이상의 쓰레드를 상대적으로 느리게 실행시키거나 혹은 실행을 늦추는 방법이다. 이 포스트에서는 두 가지 문제점이 어떻게 일어날 수 있는지 먼저 알아보고, 해결 방법까지 알아보도록 하자. ⒉ Thead interference... </summary> </entry> <entry><title>Java's Concurrency - 2 (Thread management)</title><link href="https://yongjukwon.github.io/posts/java-concurrency-2-thread-management/" rel="alternate" type="text/html" title="Java's Concurrency - 2 (Thread management)" /><published>2022-07-22T22:27:00-07:00</published> <updated>2022-07-22T22:27:00-07:00</updated> <id>https://yongjukwon.github.io/posts/java-concurrency-2-thread-management/</id> <content src="https://yongjukwon.github.io/posts/java-concurrency-2-thread-management/" /> <author> <name>Yongju Kwon</name> </author> <category term="Programming" /> <category term="Java" /> <summary> ⒈ Background 오늘은 지난 글에 이어 현재 동작하고 있는 thread를 control 할 수 있는 세 가지 방법에 대해서 알아보려고 한다. Sleep Interrupts Joins 하나씩 알아본 후에 세 가지 방법이 모두 포함된 example을 통해 어떻게 사용할 수 있는지 알아보자. ⒉ Sleep Thread.sleep은 일정 시간동안 현재 실행 되고 있는 작업을 미루는 역할을 한다. 멈춘 작업이 실행되고 있던 프로세서를 다른 쓰레드나 어플리케이션이 이용하게 할 수 있다는 점에서 유용하다. sleep 메소드는 두 가지가 존재 하는데 ¹ millisecond만 넣거나, ² millisecond와 nanosecond를 함께 넣을 수 있다. 후자의 경우 제공된 millise... </summary> </entry> <entry><title>Java's Concurrency - 1 (Basic)</title><link href="https://yongjukwon.github.io/posts/java-concurrency-1-basic/" rel="alternate" type="text/html" title="Java's Concurrency - 1 (Basic)" /><published>2022-07-08T19:51:00-07:00</published> <updated>2022-07-08T19:51:00-07:00</updated> <id>https://yongjukwon.github.io/posts/java-concurrency-1-basic/</id> <content src="https://yongjukwon.github.io/posts/java-concurrency-1-basic/" /> <author> <name>Yongju Kwon</name> </author> <category term="Programming" /> <category term="Java" /> <summary> ⒈ Background 블로그 스터디원 중 한 분이 Java로 개발할 때 Thread를 따로 만들어주지 않으면 그건 Single-Threaded application인가 라는 질문을 주셔서 간단하게 답해보고, 개발자가 어떻게 Thread를 생성할 수 있는지 간단하게 알아보려고 한다. ⒉ Is Java Single-Threaded application without explicitly created threads? JVM이 실행될 때, 보통은 오직 하나의 Non-Daemon Thread(혹은 User Thread)가 존재하게 된다. 우리가 매일 같이 쓰고 있는 main method가 실행되는 main thread이다. Daemon Thread는 JVM에 의해서 background에서 실행되고 gar... </summary> </entry> <entry><title>How does JVM work</title><link href="https://yongjukwon.github.io/posts/how-does-jvm-work/" rel="alternate" type="text/html" title="How does JVM work" /><published>2022-06-24T23:26:00-07:00</published> <updated>2022-06-27T22:07:55-07:00</updated> <id>https://yongjukwon.github.io/posts/how-does-jvm-work/</id> <content src="https://yongjukwon.github.io/posts/how-does-jvm-work/" /> <author> <name>Yongju Kwon</name> </author> <category term="Programming" /> <category term="Java" /> <summary> 이 글을 먼저 읽고 오는 걸 추천드립니다: JVM, JRE and JDK ⒈ What is Java Virtual Machine(JVM) Java Virtual Machine(JVM)의 주된 목적은 Java 컴파일러를 통해 변환된 Byte code(.class 파일)를 Machine code로 변환해주는 것이다. 이 글에서는 JVM의 아키텍쳐를 함께 보면서 어떻게 변환 과정이 이루어지는 지 알아볼 것이다. JVM의 아키텍쳐는 아래 그림과 같고, 세 가지 큰 요소로 이루어져 있다. Class Loader Subsystem Runtime Data Area Execution Engine JVM Architecture simple version(careerbless.com) 3가지 요... </summary> </entry> </feed>